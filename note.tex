% !TEX program = xelatex
\documentclass[UTF8,AutoFakeBold,zihao=-4,scheme=chinese]{ctexart}
\usepackage{zhlipsum}

\usepackage{{qyd-hyperref}}
\usepackage{qyd-geometry}
\usepackage{qyd-listings}
\usepackage{qyd-enumitem}
\usepackage{qyd-algorithm}
\usepackage{qyd-sjqy}
\usepackage{qyd-table}
\usepackage{qyd-pifont-circlednum}
\usepackage{qyd-tikz-textcircled}
\usepackage{qyd-xuni-textcircled}
%  不建议使用 \usepackage{qyd-hook-circled-number}
\usepackage{qyd-footnote}
% 选项：numstyle= pifontrm | pifontsf | tikzcirc | xunicirc | normtype |

\begin{document}

\title{自定义笔记}
\author{ADUN}
\maketitle

\section{脚注美化}

中文 gb7714-2015\footnote{foo}的内容。
中文 gb7714-2015\footnote{foo}的内容。
中文 gb7714-2015\footnote{foo}的内容。
中文 gb7714-2015\footnote{foo}的内容。
中文 gb7714-2015\footnote{foo}的内容。
中文 gb7714-2015\footnote{foo}的内容。
中文 gb7714-2015\footnote{foo}的内容。
中文 gb7714-2015\footnote{foo}的内容。
中文 gb7714-2015\footnote{foo}的内容。
% 中文 gb7714-2015\footnote{foo}的内容。

\section{带圈数字}

原生命令\textcircled {1} 绘制Tikz圆形\tikzcircled{1} 更改Unicode字体 \xunicircled{1} 的带圈数字。

原生命令\textcircled {a} 绘制Tikz圆形\tikzcircled{a} 更改Unicode字体 \xunicircled{a} 的带圈数字。

原生命令\textcircled {20} 绘制Tikz圆形\tikzcircled{20} 更改Unicode字体 \xunicircled{20} 的带圈数字。

原生命令\textcircled {22} 绘制Tikz圆形\tikzcircled{22} 更改Unicode字体 \xunicircled{22} 的带圈数字。

原生命令\textcircled {122} 绘制Tikz圆形\tikzcircled{122} 更改Unicode字体 \xunicircled{122} 的带圈数字。

原生命令\textcircled {479} 绘制Tikz圆形\tikzcircled{479} 更改Unicode字体 \xunicircled{479} 的带圈数字。

\section{基本列表}

\begin{enumerate}
  \item 中文 gb7714-2015.bbx
  \item gb7714-2015.bbx
  \item 中文 gb7714-2015ay.bbx
  \item gb7714-2015ay.bbx
\end{enumerate}

也挺常用的无序列表。

\begin{itemize}
  \item 中文 gb7714-2015.bbx
  \item gb7714-2015.bbx
  \item 中文 gb7714-2015ay.bbx
  \item gb7714-2015ay.bbx
\end{itemize}

本次修改的发起者，用description列表展示。
感觉这是一种不怎么常用的列表\footnote{大概是因为 word 中没有吧哈哈哈}。

\begin{description}
  \item[CNchence] 在github.com CNchence
  \item[marquistj13] 在github.com marquistj13
  \item[Wenda] 在github.com Williamwenda
  \item[CNchence] 在github.com CNchence
  \item[Wenda] 在github.com Williamwenda
\end{description}

更常见的是嵌套列表。

\subsection{嵌套}

先填充一些废话。\zhlipsum[6]

区别在于，本小节的例子完全展示了\emph{默认参数}情况下的样式。

首先是有序列表。
\begin{enumerate}
  \item 介绍了时间序列分析的相关概念与理论。
  \item 重点对时间序列的平稳性特点、检验方法及平稳模型体系做了详细阐述。
  \begin{enumerate}
    \item 为充分反映出监测序列的季节周期性，建立了一套基于单测点监测序列的季节 ARIMA 模型分析方法。
    \item 对建模过程中的平稳性检验、模型建立步骤、定阶、参数估计以及检验进行了系统的阐述，
  \end{enumerate}
  \item 并对玉峰大桥某监测测点的实测数据进行了季节 ARIMA 建模与预测分析。
  \item 结果表明季节 ARIMA 模型能较好地模拟监测序列的变化趋势，预测精度较高。
  \begin{enumerate}
    \item 用力地嵌套列表。
    \begin{enumerate}
      \item 针对监测序列中某些测点间具有较高的相似性，
      \item 探讨了滞后协整分析的参数估计、模型检验等方法，
    \end{enumerate}
    \item 最后建立了支座位移与温度间的 ADL 与 ECM 模型，
    \item 结果表明该模型具有良好的拟合精度与预测效果。
  \end{enumerate}
\end{enumerate}

然后是无序列表的。
\begin{itemize}
  \item 介绍了时间序列分析的相关概念与理论。
  \item 重点对时间序列的平稳性特点、检验方法及平稳模型体系做了详细阐述。
  \begin{itemize}
    \item 为充分反映出监测序列的季节周期性，建立了一套基于单测点监测序列的季节 ARIMA 模型分析方法。
    \item 对建模过程中的平稳性检验、模型建立步骤、定阶、参数估计以及检验进行了系统的阐述，
  \end{itemize}
  \item 并对玉峰大桥某监测测点的实测数据进行了季节 ARIMA 建模与预测分析。
  \item 结果表明季节 ARIMA 模型能较好地模拟监测序列的变化趋势，预测精度较高。
  \begin{itemize}
    \item 用力地嵌套列表。
    \begin{itemize}
      \item 针对监测序列中某些测点间具有较高的相似性，
      \item 探讨了滞后协整分析的参数估计、模型检验等方法，
    \end{itemize}
    \item 最后建立了支座位移与温度间的 ADL 与 ECM 模型，
    \item 结果表明该模型具有良好的拟合精度与预测效果。
  \end{itemize}
\end{itemize}

下面是一个description列表，不知道中文叫什么。

\begin{description}
  \item [linxdcn] (在github.com linxdcn TongjiThesis)同学汇总的wildwolf、
  \item [svandex] 在github.com svandex masthesis、
  \begin{description}
    \item [zhao-chen] 在github.com zhao-chen TongjiThesis的版本。
    \item [收藏有本硕博模板的zhouyuan版] 在github.com zhouyuan/tongjithesis。
  \end{description}
\end{description}

\zhlipsum[33]

顺便测试一下一个复杂的多级列表。
其实就是在嵌套的基础上， 手动定制多级列表的 label 形式。

\begin{enumerate}[1.]
  \item 调整本地工作目录
  \item 创建项目
  \begin{enumerate}[a.]
    \item 在git网站建立好新项目，把库克隆到本地

      \verb| git clone http:// |

    \item 或者，直接在本地文件夹目录下初始化

      \verb| git init |

      本地初始化后，如要连接网络远程仓库可以再用

    \verb| git remote add |
  \end{enumerate}

  \item 工作区 -> 暂存区：add添加（也叫stage）
    \begin{enumerate}[A.]
      \item 保存修改并添加文件到暂存区（index，或叫staging area)

      \verb| git add <文件名> |

      常用简化命令如下：
        \begin{itemize}[\textbullet]
          \item \verb| git add -A % 所有更改 |
          \item \verb| git add .  % 新增、修改，不含删除 |
          \item \verb| git add -u % 修改、删除，不含新增 |
        \end{itemize}

      \item 或者查看区别

      \verb!git diff!
    \end{enumerate}

  \item 暂存区 -> 版本库：commit提交

  \verb| git commit -a -m "message" |

  其中，-a 表示全部 -m 添加一个留言。
  \begin{enumerate}[(a)]
    \item 如果弹出了vim截面，则用i命令进入编辑模式，输入完成后，esc退回到命令模式，
    \item 然后：wq保存并退出vim，即可回到git命令窗口。
  \end{enumerate}

  \item * 确认提交状况  git status

  \item 推送到远程仓库

  \verb| git push -branch |

  之前步骤1-5都是在本地的版本管理，直到这一步才牵扯。
\end{enumerate}

下面是行内列表的展示。

\begin{inline}[1)]
  \item 中文 gb7714-2015.bbx
  \item gb7714-2015.bbx
  \item 中文 gb7714-2015ay.bbx
  \item gb7714-2015ay.bbx
  \item 中文 gb7714-2015.bbx
  \item gb7714-2015.bbx
  \item 中文 gb7714-2015ay.bbx
  \item gb7714-2015ay.bbx
\end{inline}


\section{表格测试}

常用的表格是三线表。

\begin{table}[htb]
\centering
\caption{这不是个图}
\label{tab:fig}
\begin{tabular}[c]{lll}
  \toprule[1.5pt]
  0 & 1 & 2 \\ % title row
  \midrule[1pt]
  0 & 1 & 2 \\ % title row
  0 & 1 & 2 \\ % title row
  \bottomrule[1.5pt]
\end{tabular}
\end{table}

先填充一些废话。\zhlipsum[7]

在这里学习一下新定义的列形式。

\begin{table}[htb]
\centering
\caption{tabularx}
\label{tab:tabularx}
\begin{tabularx}{0.7\textwidth}{>{\raggedleft\arraybackslash}X>{\raggedleft\arraybackslash}X>{\centering\arraybackslash}X}
  \toprule[1.5pt]
  0 & 1 & 2 \\ % title row
  \midrule[1pt]
  0 & 1 & 2 \\ % title row
  0 & 1 & 2 \\ % title row
  \bottomrule[1.5pt]
\end{tabularx}
\end{table}

\section{代码环境}
\label{sec:code}

常用的代码展示，基于 Listings 宏包。

\subsection{Listings 环境展示}
\label{ssc:listings}

\begin{lstlisting}[style=monocolor,
  caption={first lst env},
  label={no label},
  name=测试第一个代码,
  language=PythonPlus]
  # import lxml
  import requests
  from bs4 import BeautifulSoup
  import re
\end{lstlisting}

先填充一些废话。\zhlipsum[8]

为 宏包 Listings 定义了许多种语言和样式，比如XML，再基于XML定义了 ParamML。
语法比较简单，看看 tongjithesis.sty 文件 也就懂了。
故不赘述。

第~\ref{sec:code} 小节的内容也被引用了。

\begin{lstlisting}[language=Python,
  caption=中文标题没有括号,
  label=lst:outer,
  style=colored]

  import numpy a np
  def incmatrix(genl1,genl2):
      m = len(genl1)
      # compute the bitwise xor matrix
      M1 = bitxormatrix(genl1)
      for i in range(m-1):
          for j in range(i+1, m):
              [r,c] = np.where(M2 == M1[i,j])
              for k in range(len(r)):
                  VT[(i)*n + r[k]] = 1;
      return M
\end{lstlisting}

\subsection{算法}

比代码更加抽象的方式就是算法展示了。

先填充一些废话。\zhlipsum[7]

\begin{minipage}{0.75\textwidth}

\begin{algorithm}[H]
  \caption{测试算法}
  \label{alg:test}
    \begin{algorithmic}[1]
      \REQUIRE PDf
      \ENSURE xelatex biber xelatex*2
      \IF{some condition is true}
      \STATE do some processing
      \ELSIF{some other condition is true}
      \STATE do some different processing
      \ELSIF{some even more bizarre condition is met}
      \STATE do something else
      \ELSE
      \STATE do the default actions
      \ENDIF
    \end{algorithmic}
  \end{algorithm}

\end{minipage}
\newline

但是好像用上的机会不多。

algorithm 是个 float 环境，相当于 table。
其宽度用 minipage 可以调整宽度，但是会取消 \textbackslash intextsep 导致上下间距过小。

\begin{enumerate}[(1)]
  \item 偷懒的方案是手动加竖向间距。
  \item 更好的方案是用另一个可以接受宽度的的浮动体包围、algorithm 以选项 H 放置其中。
  比如 tcolorbox、fullwidth 等。
\end{enumerate}

\section{钢筋符号}
用 SJQY 字体生成 钢筋符号，自定义了命令。
\stA
\stB
\stC
\stD
\stE

\section{Totalcommander}

TC 是一款\textbf{强大}的文件管理软件，提供了许多便捷功能，可以 取代windows资源管理器。
（虽然有一定上手难度，而且界面丑）。

主要参考教程 http://xbeta.info/studytc/index.html

\section{原因}
下面是选择他的主要原因。
\subsection{ 快速启动 }
把 TOTALCMD.EXE(32bit) 的 .lnk快捷方式 设置一个快捷键ctrl+alt+q，实现全局调用。
需要把win+r路径添加到用户path中之后重启explorer才能有效。
因为不少插件只有32bit版本，所以优先用 tc32

\subsection{ 左右窗口启动目录}
1. 可以在上述.lnk快捷方式的Target选项用\textbackslash l\textbackslash r制定启动时的左右窗口默认地址。
\textbackslash l=cd ::{20D04FE0-3AEA-1069-A2D8-08002B30309D}
\textbackslash r=cd ::{031E4825-7B94-4DC3-B131-E946B44C8DD5}\textbackslash Documents.library-ms
2. 更好的方式是直接在wincmd.ini中配置初始启动目录了。
通过 [left].path= 和 [right].path=
地址获取方法
启动tc并打开目标位置，【configuration】->【sava position】保存之后关闭；
去安装目录的wincmd.ini文件里找到历史。

\section{TC配置}
TC的配置文件是 wincmd.ini，一般放在其安装目录下。
重新部署
所以，即使换了电脑，也能通过复制旧的 wincmd.ini 和 usercmd.ini 并覆盖，转移绝大多数的配置，主要包括样式、快捷键。
新装机之后需要重新部署的是【收藏夹】【重装插件】

配置文件内容
a. 样式
样式就不多说了，最大亮点就是并排窗口，其次是按照文件类型出现颜色（例如我用的是最近修改时间）。
此外，还有奇数偶数行稍有差别的配色等特征。
b. 常用的快捷键：
TC 丰富且可自定义的快捷键，对我来说，是相比win资源管理器的一大优势。
○ F2重命名跟系统一样
○ F3查看，F4修改，在加上系统默认的双击打开，同一个文件在tc下有三种不同的处理方式。
○ F5复制、F6移动可以替代两次ctrl+c/v/x
○ ctrl+1/2/3 复制文件名/路径/全路径+文件名
○ ctrl+y/g 压缩/解压缩
○ ctrl/alt + +/-进行全选/全不选/选同样后缀
○ alt+左右q 跳转历史
c. 其它ini设置
还有其它有用的配置，曾经用过的。
绿色TC	UseIniInProgramDir=7
数字排序	SortUpper=2 	1,2,…10,11而不是1,10,11,2,…
ini文件的注释	用分号;
而更多的快捷键，是快速定位 hotlist：类似于收藏夹的一个功能。

\section{文件目录}
双窗口
TC 相比传统 win 资源管理器，最显眼的特点是双窗口，区分了工作目录和目标目录，方便了“文件转移”这个操作。
目录跳转
与之相匹配的，就是目录的快速定位。
a. 最常用的文件夹，例如“电脑”“下载目录”“桌面”分配了专有的快捷键，比如ctrl+alt+d跳转到download目录下。
b. 其次常用的文件夹，纳入了收藏夹（ctrl/alt+d），之后通过首字母进行跳转。
新装机之后要重新配置的主要内容，因为盘符和目录结构可能会有不同。
c. 不是太常用的目录，就依靠快速搜索功能（ctrl+s）完成了。
配置中AltSearch=3（使用快速搜索窗口），则在目录下直接按键输入字符，可以匹配目标文件名。
而快速搜索甚至可以用正则表达式 ？！这就要用到插件了。
d. 如果还是嫌麻烦，就参考联系 everything 的协作。
当然，最根本的，还是用户良好的文档命名习惯。

\section{插件}
因为丰富的插件才让tc有了巨大的扩展性。

\subsection{QuickSearch eXtended}
就是刚刚说的用于加强快速搜索功能的插件。
最初要依靠它才能匹配中文拼音，现在这个需求已经降低。几个新版本tc对汉语的等非英语语种有了支持。
它的安装如果失败了，就手动把tcmatch.exe放到tc.exe同目录下。
\subsection{F4menu-modified}
原生的F4编辑不能适应不同后缀对应不同程序的需求。所以一个F4menu就是必需的。
不过，好像tc对它的支持不怎么好。所以需要自己解压到plugins文件夹下，然后在options中设置到F4menu.exe
\subsection{util\_TCPlugman}
插件管理。当初有大量插件的时候会用，现在想来也有点鸡肋了。
\subsection{查看类}
就是调用F3时候的插件，可以对图片、代码，甚至office文档。通过查看模式打开，一是启动速度更快，更重要的是可以避免误操作的删除、修改。
wlx\_uLister 对office进行预览，强烈推荐。而且也能支持其他的不少插件，可以说是一站式的选择。
首先安装ulister，
然后按照其readme文件说明，去 \url{http://www.oracle.com/technetwork/middleware/content-management/downloads/oit-dl-otn-097435.html} 下载 Viewer Technology 文件包
并把制定的redist文件夹复制到ulister的目录中。
\subsection{处理类}
wcx\_7zip 可以支持7zip格式的压缩包。考虑到我用的压缩软件就是7zip，所以还是装上。

\section{关联程序}
除了在wincmd.ini中的程序设置外，还有几处自己的习惯。

用户命令：设置usercmd.ini
主要有调用everything和系统资源管理器两个。

\begin{verbatim}
    [em_everything]
    button=
      C:\Users\yqin78\Documents\1AETV\Everything\Everything.exe
    cmd=
      "C:\Users\yqin78\Documents\1AETV\Everything\Everything.exe"
    param=-search "%P "
    path=.

    [em_explorer]
    button=C:\Windows\explorer.exe
    cmd=C:\Windows\explorer.exe
    param=.
    path=.
\end{verbatim}

然后在快捷键中为这些 usercmd 绑定快捷键。

在 everyting 中调用 TC
everything也是我喜欢的软件，专业搜索。
通常喜欢把右键菜单的浏览/浏览路径改为调用totalcommander。

\begin{verbatim}
    explore_command2=$exec(
      "c:\Users\yqin78\Documents\1AETV\totalcmd\TOTALCMD.EXE"
      "/O" "/T" "%1")
    explore_path_command2=$exec(
      "c:\Users\yqin78\Documents\1AETV\totalcmd\TOTALCMD.EXE"
      "/O" "/T" "$parent(%1))
\end{verbatim}

\end{document}
